import { repoCrawlerAgent } from './agents/RepoCrawlerAgent';
import type { AgentResponse } from '@/types/agents';

/**
 * AgentOrchestrator coordinates multiple AI agents to process repository data
 * and generate comprehensive tutorials
 */
export class AgentOrchestrator {
  private agents: {
    repoCrawler: typeof repoCrawlerAgent;
    // TODO: Add other agents here as they are implemented
    // analyzer?: AnalyzerAgent;
    // writer?: WriterAgent;
  };

  constructor() {
    this.agents = {
      repoCrawler: repoCrawlerAgent,
    };
  }

  /**
   * Execute the full multi-agent workflow to generate a tutorial
   */
  async generateTutorial(repoUrl: string): Promise<{
    success: boolean;
    tutorial?: string;
    error?: string;
    agentResults?: Record<string, AgentResponse>;
  }> {
    console.log('[Orchestrator] Starting multi-agent tutorial generation');
    const agentResults: Record<string, AgentResponse> = {};

    try {
      // Step 1: RepoCrawler fetches repository data
      console.log('[Orchestrator] Step 1: Fetching repository data...');
      const crawlerResult = await this.agents.repoCrawler.fetchRepoData(repoUrl);
      agentResults['repoCrawler'] = crawlerResult;

      if (!crawlerResult.success) {
        throw new Error(`RepoCrawler failed: ${crawlerResult.error}`);
      }

      console.log('[Orchestrator] RepoCrawler completed successfully');

      // TODO: Step 2: Analyzer agent processes the data
      // TODO: Step 3: Writer agent generates the tutorial

      // For now, generate a tutorial from the crawler data
      const tutorial = this.generateTutorialFromCrawlerData(crawlerResult.data);

      return {
        success: true,
        tutorial,
        agentResults,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('[Orchestrator] Error:', errorMessage);

      return {
        success: false,
        error: errorMessage,
        agentResults,
      };
    }
  }

  /**
   * Generate tutorial markdown from crawler data
   * This will be replaced by a dedicated Writer agent
   */
  private generateTutorialFromCrawlerData(repoData: any): string {
    const { metadata, readme, fileTree, keyFiles } = repoData;

    let tutorial = `# Tutorial: ${metadata?.name || 'Repository'}\n\n`;

    // Metadata section
    if (metadata) {
      tutorial += `## Repository Overview\n\n`;
      tutorial += `**Description:** ${metadata.description}\n\n`;
      tutorial += `**Primary Language:** ${metadata.language}\n\n`;
      tutorial += `**Community:** ${metadata.stars} ‚≠ê | ${metadata.forks} üç¥\n\n`;
    }

    // README section
    if (readme) {
      tutorial += `## README\n\n${readme}\n\n`;
    }

    // File structure
    if (fileTree && fileTree.length > 0) {
      tutorial += `## Project Structure\n\n`;
      tutorial += "```\n";
      tutorial += fileTree.join('\n');
      tutorial += "\n```\n\n";
    }

    // Key files
    if (keyFiles && Object.keys(keyFiles).length > 0) {
      tutorial += `## Key Files\n\n`;
      for (const [filename, content] of Object.entries(keyFiles)) {
        tutorial += `### ${filename}\n\n`;
        tutorial += "```\n";
        tutorial += content;
        tutorial += "\n```\n\n";
      }
    }

    // Agent info footer
    tutorial += `---\n\n`;
    tutorial += `*Generated by CodeSensei Multi-Agent System*\n`;
    tutorial += `- üß† **RepoCrawler Agent**: Repository data fetched via MCP\n`;
    tutorial += `- üìä **Analyzer Agent**: Coming soon...\n`;
    tutorial += `- ‚úçÔ∏è **Writer Agent**: Coming soon...\n`;

    return tutorial;
  }

  /**
   * Get status of all agents
   */
  getAgentsStatus(): Record<string, { name: string; role: string; status: string }> {
    return {
      repoCrawler: {
        name: this.agents.repoCrawler.getConfig().name,
        role: this.agents.repoCrawler.getConfig().role,
        status: 'active',
      },
      // TODO: Add other agents
    };
  }
}

// Export singleton instance
export const agentOrchestrator = new AgentOrchestrator();
